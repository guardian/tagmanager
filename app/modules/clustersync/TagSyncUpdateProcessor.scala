package modules.clustersync

import com.amazonaws.services.kinesis.model.Record
import com.gu.tagmanagement.{EventType, TagEvent}
import model.Tag
import play.api.Logger
import repositories.TagLookupCache
import services.KinesisStreamRecordProcessor

import scala.util.{Failure, Success, Try}

object TagEventDeserialiser {

  import services.KinesisRecordPayloadConversions._

  /**
   * 03 Sep 2019
   * @stripCompressionByte in kinesisRecordAsThriftCompactProtocol is set to true
   * because the Kinesis thrift blob producer `KinesisStreamProducer.publishUpdate` by using `ThriftSerializer.serializeToBytes`
   * adds compression byte at the beginning while producing the feed
   * it was like that in past, so we decided to keep that logic in `ThriftSerializer.serializeToBytes` because
   * there are other consumers of the feeds generated by this application
   *
   * In tag manager
   * the latest thrift serialisation library that we use here is nat handling that additional byte
   * so we decided to explicitly strip it while reading the feed back from Kinesis
   * */
  def deserialise(record: Record): Try[TagEvent] = {
    val tProto = kinesisRecordAsThriftCompactProtocol(record, stripCompressionByte = true)
    Try(TagEvent.decode(tProto))
  }

}

object TagSyncUpdateProcessor extends KinesisStreamRecordProcessor {

  override def process(record: Record) {
    Logger.info(s"Kinesis consumer receives record \n $record")
    TagEventDeserialiser.deserialise(record) match {
      case Success(tagEvent) => updateTagsLookupCache(tagEvent)
      case Failure(exp) =>
        Logger.error(s"issue while TagEvent decode:\n ${exp.getMessage}")
    }
  }

  private def updateTagsLookupCache(tagEvent: TagEvent): Unit = {
    Logger.error(s"TagEvent received: \n $tagEvent")
    tagEvent.eventType match {
      case EventType.Update =>
        Logger.info(s"inserting updated tag ${tagEvent.tagId} into lookup cache")

        tagEvent.tag match {
          case Some(thriftTag) => TagLookupCache.insertTag(Tag(thriftTag))
          case None =>
            Logger.warn(s"TagEvent for ${tagEvent.tagId} did not contain any tag object")
        }
      case EventType.Delete =>
        Logger.info(s"removing tag ${tagEvent.tagId} from lookup cache")
        TagLookupCache.removeTag(tagEvent.tagId)
      case et =>
        Logger.warn(s"unrecognised event type ${et.name}")
    }
  }
}
